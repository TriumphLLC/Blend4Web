
Objects
*******


Table of Contents
^^^^^^^^^^^^^^^^^

* Objects

  * Types

  * Static and Dynamic Objects

  * Settings

    * Object Tab

    * Physics Tab

  * Object Transform API

  * Get object API

  * Quaternions

    * Quaternion Example

  * Differences Between Coordinate Systems of Blender and Blend4Web

  * Moving via TSR Vectors

Objects are intended to position components of different types
(meshes, cameras, lamps etc) in a 3D scene space.


Types
=====

The engine supports objects of the following types:

   * meshes (mesh)

   * camera

   * lamp

   * empty

   * armature

   * speaker

   * curve

   * text

   * metaball

   * surface


Static and Dynamic Objects
==========================

**Static objects** are objects which can be merged together if they
have the same material.

**Dynamic objects** are objects which cannot be combined with each
other.

Only "MESH", "CAMERA" and "ARMATURE" type objects can be dynamic. All
other object types are static.

The objects which have animation, physics or a parent, which is a
dynamic object, are considered dynamic.

Object movement via API is possible only for dynamic objects. In order
to make the movement of the object without dynamic settings possible,
it is necessary to activate "Force Dynamic Object" option in its
settings.


Settings
========

The following is supported for all types of objects: transform, data
reference, parent object, group membership and a set of the
Blend4Web’s special properties.


Object Tab
----------

[图片]



*Transform > Location*
   Position coordinates.

*Transform > Rotation*
   Rotation angles. For the object rotation all available modes can be
   used ("Rotation Mode"). However only "Quaternion (WXYZ)" and "XYZ
   Euler" are supported for object animation.

*Transform > Scale*
   Scaling. All 3 components (x, y, z) should be the same. Scaling for
   physics objects is not supported.

*Relations > Parent*
   Reference to the parent object.

   If the parent object is a camera, "Viewport Alignment" settings
   will be avalible.

   [图片]

   The "Alignment" parameter specifies to what side of the viewport an
   object will be aligned ("Center" by default). The "Distance"
   parameter specifies the distance between the aligned object and the
   camera (10 by default). The "Fit to Camera" button can be used to
   make the aligned object look in the Blender viewport same way it
   will look in the engine.

*Groups*
   Objects’ groups to which this object belongs.

[图片]



*Levels of Detail > LOD Transition Ratio*
   Parameter for smoothing the switching between the LOD objects. It
   defines the additional distance at which the LOD objects are still
   rendered before getting replaced by the next LOD objects. Assigned
   for the main object. Measured in fractions of the object’s bounding
   sphere radius.

*Special Effects > Disable Fogging*
   Disable fog for the object.

*Special Effects > Caustics*
   The object will render caustics effects from the adjacent water.

*Export Options > Do Not Export*
   Do not export this object.

*Export Options > Apply Modifiers*
   Apply the object’s modifiers upon export. If the "SKIN" modifier is
   used we recommend to apply it before the export because it resets
   vertex color and UV layers which may result in errors.

*Export Options > Apply Scale and Modifiers*
   Upon export, apply scale and modifiers for the object.

*Export Options > Export Vertex Animation*
   Export previously created and saved vertex animation. Applicable
   for "MESH" type objects only.

*Export Options > Export Shape Keys*
   Export shape keys. Applicable to "MESH" type objects only.

注解: The following properties are mutually exclusive: *Apply
  Modifiers*, *Apply Scale and Modifiers*, *Export Vertex Animation*
  and *Export Shape Keys*.

*Animation > Apply Default Animation*
   Upon loading into the engine start playback of the animation
   assigned to the object.

*Animation > Animation Blending*
   Only for armature objects. Allows blending between skeletal
   animations.

*Animation > Behavior*
   Animation behavior when the last frame is reached: "Finish Stop" -
   stop, "Finish Reset" - stop and go to the zero frame, "Loop" -
   repeat forever.

*Rendering Properties > Do Not Render*
   Disable object rendering (for example useful for a physics object).

*Rendering Properties > Disable Frustum Culling*
   Disable frustum culling optimization.

*Rendering Properties > Force Dynamic Object*
   Force the object to become a dynamic object.

*Rendering Properties > Dynamic Geometry*
   Allow overriding of the object’s geometry through Blend4Web API.

*Shadows > Cast*
   The object will cast shadows.

*Shadows> Cast Only*
   The object will cast shadows but will remain invisible itself.
   Becomes available after enabling "Shadows > Cast".

*Shadows > Receive*
   The object will receive shadows from other adjacent objects.

*Reflections > Reflexible*
   When enabled the object is reflected in the dynamic mirror
   surfaces.

*Reflections > Reflexible Only*
   The object will be reflected but will remain invisible itself.
   Becomes available after enabling "Reflections > Reflexible".

*Reflections > Reflective*
   When enabled the object surface reflects other objects.

*Reflections > Reflection Plane*
   Text field for name of an empty object which defines the reflection
   plane. Becomes available after enabling "Reflections > Reflective".

*Selection and Outlining > Selectable*
   Enable object selection with the mouse or another input device.

*Selection and Outlining > Enable Outlining*
   Enable outline glow for the object.

*Meta Tags*
   Interface for adding meta tags to the object:

   *Meta Tags > Title*
      Object's title.

   *Meta Tags > Category*
      Object's category.

   *Meta Tags > Description*
      Description for the object. Depending on "Description Source",
      this field accepts either description text itself, or the name
      of a file where this description is contained.

   *Meta Tags > Description Source*
      Source type for the description: text or text file.

*Anchors > Enable Anchor*
   Available for "EMPTY" objects only. Interface for adding anchors
   (2D tags) to objects:

   *Anchors > Type*
      Anchor type. "Annotation" - the content is obtained from the
      meta tags assigned to the object and displayed in a collapsible
      window of standard design. "Custom Element" - arbitrary HTML
      element from the current web page is used as anchor. "Generic" -
      anchor’s position can be detected using "anchors" API module.

   *Anchors > Detect Visibility*
      Detect whether the anchor object is overlapped by other objects.
      Turning this option on decreases performance and should be used
      only when necessary.

   *Anchors > Max Width*
      Applicable to annotation anchors. This limits the expanding info
      window by a predefined value (measured in CSS pixels).

*Wind Bending*
   Enables wind bending procedural animation. Thoroughly described at
   the outdoor rendering page.

*Billboard*
   Use the object as a billboard (i.e. automatically orient relative
   to the camera).

*Billboard > Preserve Global Orientation and Scale*
   Take into account rotation and scale of the billboard object (in
   the world space). The object will be directed toward the camera
   with its side which is visible when viewing along the Y axis in
   Blender. Becomes available after enabling the "Billboard" checkbox.

*Billboard > Billboard Type*
   Billboard orientation mode. "Spherical" (by default) - the object
   is always oriented with one side toward the camera, regardless of
   view angle, "Cylindrical" - similar to "Spherical", but rotation is
   limited to Blender’s world Z axis. Becomes available after enabling
   Billboard


Physics Tab
-----------

[图片]



*Detect Collisions*
   Activate the object’s physics.

*Floating*
   Make the object floating. The settings for floating objects are
   described in detail in the physics section.

*Vehicle*
   Use the object as part of a vehicle. The vehicle settings are
   described in detail in the physics section.

*Character*
   Use the object for character physics. The character settings are
   described in detail in the physics section.


Object Transform API
====================

注解: Make sure that the object you are trying to transform is a
  dynamic object.

Use the following methods of the transform module to move objects in
the engine:

get_translation()
   Get the coordinates of the object’s center in world space. The
   method with a single argument returns a new vector (i.e. this is a
   non-optimized option) while the method with two arguments requires
   an additional vector to write the result down.

get_translation_rel()
   Similar to the "get_translation()" method, but if this object has a
   parent, the obtained coordinates are measured in the parent’s
   space.

set_translation(), set_translation_v()
   Move the object’s center into the specified location. The first
   method takes separate coordinates as arguments while the second one
   takes a three-component vector ("Array" or "Float32Array").

set_translation_rel(), set_translation_rel_v()
   Similar to "set_translation()" and "set_translation_v()", but if
   this object has a parent, the set coordinates are measured in the
   parent’s space.

get_rotation()
   Get the object’s rotation quaternion in world space. Similar to
   "get_translation()", there are two options for calling this
   function.

get_rotation_rel()
   Get the object’s rotation quaternion measured in its parent’s
   space. Similar to "get_translation_rel()", there are two options
   for calling this function.

set_rotation(), set_rotation_v()
   Set the object’s rotation quaternion in world space. The first
   function takes separate coordinates as arguments while the second
   one takes a four-component vector ("Array" or "Float32Array").

set_rotation_rel(), set_rotation_rel_v()
   Set the object’s rotation quaternion measured in its parent’s
   space. The first function takes separate coordinates as arguments
   while the second one takes a four-component vector ("Array" or
   "Float32Array").

get_scale()
   Get the object’s scale in world space.

get_scale_rel()
   Get the object’s scale in its parent’s space.

set_scale()
   Set the object’s scale in world space. Unity corresponds to the
   original scale of the object. Values less than unity mean scaling
   down, bigger than unity - scaling up. Note that not all objects can
   be scaled. Particularly, scaling is not allowed for physics
   objects.

set_scale_rel()
   Set the object’s scale in its parent’s space.

set_rotation_euler(), set_rotation_euler_v()
   Set the object’s rotation using Euler angles. An **intrinsic** YZX
   rotation system is used (that means the angles follow in the YZX
   order and the origin of coordinates rotates and takes up a new
   position for every angle).

set_rotation_euler_rel(), set_rotation_euler_rel_v()
   Set the object’s rotation using Euler angles measured in its
   parent’s space.

move_local()
   Move the object relative to its original position (in local space).

rotate_x_local(), rotate_y_local(), rotate_z_local()
   Rotate the object relative to its original position (in local
   space).


Get object API
==============

To perform any operation with an object, you first need to get it
(i.e. recieve the link to it). There are several API functions for
doing this. A link to an object has "Object3D" type.

get_object_by_name()
   Get object by name.

      // ...
      var obj = m_scenes.get_object_by_name("Object");
      // ...

get_object_by_dupli_name()
   Get the duplicated object by empty name and dupli name.

      // ...
      var obj = m_scenes.get_object_by_dupli_name("Empty", "Object");
      // ...

get_object_by_dupli_name_list()
   Get the duplicated object by empty name and dupli name list (an
   array of "String" type elements).

      // ...
      var obj = m_scenes.get_object_by_dupli_name_list(["Empty1", "Empty2", "Object"]);
      // ...

get_object_name_hierarchy()
   Returns the object names hierarchy array (from the highest parent
   to the object itself) for a given object.

      // ...
      var names = m_scenes.get_object_name_hierarchy(obj);
      // ...

check_object_by_name()
   Check if object with given name is present on scene.

      // ...
      var object_exists = m_scenes.check_object_by_name("Cube");
      // ...

check_object_by_dupli_name()
   Check if duplicated object is present on scene by empty name and
   dupli name.

      // ...
      var object_exists = m_scenes.check_object_by_dupli_name("Empty", "Cube");
      // ...

check_object_by_dupli_name_list()
   Check if duplicated object is present on scene by empty name and
   dupli name list (an array of "String" type elements).

      // ...
      var object_exists = m_scenes.check_object_by_dupli_name_list(["Empty1", "Empty2", "Object"]);
      // ...

get_object_name()
   Get the object’s name.

      // ...
      var object_name = m_scenes.get_object_name(obj);
      // ...


Quaternions
===========

Quaternion is a four-component vector used to perform rotating.
Quaternions have a number of advantages over other rotation methods
such as:

   * A quaternion isn’t ambiguant and doesn’t depend on the rotation
     order as the Euler angles.

   * Quaternion’s memory usage is more effective (2-4 times less
     depending on the matrix used).

   * Better computing efficiency than for matrices in case of a
     series of rotations.

   * Numeric stability - compensation for multiplication errors
     arising from float number inaccuracy.

   * Convenient interpolation method.

Quaternions have some drawbacks:
   * Rotating a vector with a quaternion is more computationally
     expensive than rotating with a matrix.

   * It is difficult to use quaternions for non-rotation
     transformations (such as perspective or orthogonal projection).

The engine has a number of functions to make it more convenient to
work with quaternions:

*quat.multiply*
   Quaternion multiplication. Note that left-multiplying A quaternion
   by B quaternion A*B is a rotation by A. I.e. the object already has
   some rotation B which we supplement with a new rotation by A.

*quat.setAxisAngle*
   A quaternion is an alternative presentation of rotation by an
   arbitrary angle relative to the arbitrary axis (vector). Positive
   direction of rotation is defined as anticlockwise when viewing from
   the vector’s end. For example the :code`quat.setAxisAngle([1, 0,
   0], Math.PI/2, quat)` call forms a quaternion which can be used for
   rotating the object by 90 degrees (anticlockwise if viewing from
   the X axis’ end) relative to the X axis.

*quat.slerp*
   Spherical interpolation of quaternions. Used for smoothing the
   object’s rotation and animation.

*util.euler_to_quat, util.quat_to_euler*.
   Conversion from Euler angles and back.


Quaternion Example
------------------

We need to rotate the object by 60 degrees in a horizontal plane to
the right. We have a model named “Cessna” in Blender.

[图片]



Lets save a reference to the object in the **aircraft** variable:

   var aircraft = m_scenes.get_object_by_name("Cessna");

Lets rotate it:

   * The orientation of coordinate axes is different in Blender and
     in the engine. Upon export there will be a transformation [X Y Z]
     (Blender) -> [X -Z Y] (the engine). Therefore we need to rotate
     the object relative to the Y axis and not the Z axis.

   * A clockwise rotation corresponds to the rotation to the right
     (i.e. in the negative direction).

   * 60 degrees = \pi/3 radians.

As a result we get:

   // compose quaternion
   var quat_60_Y_neg = m_quat.setAxisAngle([0, 1, 0], -Math.PI/3, m_quat.create());

   // get old rotation
   var quat_old = m_transform.get_rotation(aircraft);

   // left multiply: quat60_Y_neg * quat_old
   var quat_new = m_quat.multiply(quat_60_Y_neg, quat_old, m_quat.create());

   // set new rotation
   m_transform.set_rotation_v(aircraft, quat_new);

The optimized version which does not create new objects:

   // cache arrays as global vars
   var AXIS_Y = new Float32Array([0, 1, 0])
   var quat_tmp = new Float32Array(4);
   var quat_tmp2 = new Float32Array(4);
   ...
   // rotate
   m_quat.setAxisAngle(AXIS_Y, -Math.PI/3, quat_tmp);
   m_transform.get_rotation(aircraft, quat_tmp2);
   m_quat.multiply(quat_tmp, quat_tmp2, quat_tmp);
   m_transform.set_rotation_v(aircraft, quat_tmp);


Differences Between Coordinate Systems of Blender and Blend4Web
===============================================================

In Blender’s coordinate system the "UP" vector, which points upwards,
is co-directional with the Z axis. Blend4Web uses Y axis for this
purpose, as it is customary in OpenGL. Thus the engine’s coordinates
are rotated by 90° around the X axis relative to Blender.

[图片]



API methods use the engine’s coordinates, so they can work differently
in comparison with setting Blender’s parameters.


Moving via TSR Vectors
======================

It is sometimes convenient to move objects using vectors of the
following format:

   [T_x, T_y, T_z, S, R_x, R_y, R_z, R_w]

Here T_x, T_y, T_z - the components of the translation vector, S -
scale factor, R_x, R_y, R_z, R_w - the components of the quaternion
vector. Hence the name of this vector: TSR or TSR-8.

This vector can be operated via *tsr* module, as well as via
*set_tsr()*/*get_tsr()* methods of the *transform* module.
